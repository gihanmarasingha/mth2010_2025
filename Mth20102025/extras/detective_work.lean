import Mathlib

/-
# Mathlib detective work

In this module, we dig into Mathlib to find the definition of the product of two ideals.
-/

variable {R} [CommRing R] (I J : Ideal R)

set_option pp.notation false

#check I * J


/-
The result of the above check is `HMul.hMul I J : Ideal R`.

This is our starting point. We can use `#synth` to find an instance of `HMul`. First note
(via `#check`) that `HMul` takes 3 type arguments. So we use three copies of `Ideal R` in `#synth`.
-/

#check HMul

#synth HMul (Ideal R) (Ideal R) (Ideal R)

/-
The result is `instHMul`. We can examine this.
-/

#print instHMul

/-
We get (by `#print` or just by Going to Definition in VSCode on `instHmul`):

  instance instHMul [Mul α] : HMul α α α where
  hMul a b := Mul.mul a b

So this instance of `HMul` just depends on `Mul`. This tells us we need to investigate `Mul`!

I'll continue with these `#synth` / `#print` pairs from now on with no further comment.
-/

#synth Mul (Ideal R)

#print Submodule.mul

/-
The `#synth` above gives `Submodule.mul` so we look at `Submodule.mul`. The definition is:

  /-- Multiplication of sub-R-modules of an R-module A that is also a semiring. The submodule `M * N`
  consists of finite sums of elements `m * n` for `m ∈ M` and `n ∈ N`. -/
  instance mul : Mul (Submodule R A) where
    mul := (· • ·)

  In greater detail (having used `set_option pp.notation false` above for our `#print`), the `mul`
  constructor is

    `{ mul := fun x1 x2 ↦ HSMul.hSMul x1 x2 }`

  Ah! So we need `HSMul`.
-/

#synth HSMul (Ideal R) (Ideal R) (Ideal R)

#print instHSMul

/-
We see that the instance defines `{ hSMul := SMul.smul }`.

Now we investigate `SMul`.
-/

#synth SMul (Ideal R) (Ideal R)


#print Submodule.instSMul

/-
From the `#print`, we see

smul := fun A' M' ↦
      let __spread.0 := HSMul.hSMul A'.toAddSubmonoid M'.toAddSubmonoid;

Hovering over `A'.toAddSubmonoid` in the InfoView shows the type is `AddSubmonoid A`

I guess (I need to clarify how to deduce this guess from the above!) that we need to consider
`AddSubmonoid.smul`
-/

#print AddSubmonoid.smul

/-
We see the definition:

  /-- For `M : Submonoid R` and `N : AddSubmonoid A`, `M • N` is the additive submonoid
  generated by all `m • n` where `m ∈ M` and `n ∈ N`. -/
  protected def smul : SMul (AddSubmonoid R) (AddSubmonoid A) where
    smul M N := ⨆ s : M, N.map (DistribSMul.toAddMonoidHom A s.1)
-/

/-
Here, `⊔` is notation for `iSup`, the indexed supremum (as found from the non-pretty-printed
def)
-/

#print iSup

#synth SupSet (AddSubmonoid R)

/-
The `check` shows iSup is defined for types `α` for which there is an instance of `[SupSet α]`
We examine the appropriate instance `SupSet (AddSubmonoid R)` and find it to be
`CompleteLattice.toCompletePartialOrder.toSupSet`
-/

#synth CompleteLattice (AddSubmonoid R)

#print AddSubmonoid.instCompleteLattice

/-
`#synth CompleteLattice (AddSubmonoid R)` gives

AddSubmonoid.instCompleteLattice

Examing `AddSubmonoid.instCompleteLattice` shows the CompleteLattice structure.
In particular, the `le` constructor is `le := fun x1 x2 ↦ LE.le x1 x2`.

Hovering over this in the InfoView shows that `LE.le` is applied to
`(AddSubmonoid M) SetLike.instPartialOrder.toLE x1 x2`
-/



#print SetLike.instPartialOrder

/-
Finally, the definition of `SetLike.instPartialOrder` is

instance (priority := 100) instPartialOrder : PartialOrder A :=
  { PartialOrder.lift (SetLike.coe : A → Set B) coe_injective with
    le := fun H K => ∀ ⦃x⦄, x ∈ H → x ∈ K }

Showing that `H ≤ K` just means that `H ⊆ K`.
-/
