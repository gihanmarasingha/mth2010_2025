import Mathlib

open scoped BigOperators
open Finset


/-- Pointwise product of two finsets in a group. -/
def finsetMul {G} [DecidableEq G] [Mul G] (A B : Finset G) : Finset G :=
  A.biUnion (fun a => B.image (fun b => a * b))

/-- One "groupy" expansion step: add 1, all products, and all inverses. -/
def expand {G} [DecidableEq G] [Group G] (X : Finset G) : Finset G :=
  insert 1 (X ∪ finsetMul X X ∪ X.image (fun x => x⁻¹))

/-- Start from the seed set `T` (plus `1`) and iterate `expand` at most `|G|` times.
    In a finite group this stabilises at the subgroup generated by `T`. -/
def boundedClosure
    {G} [DecidableEq G] [Fintype G] [Group G] (T : Finset G) : Finset G :=
  let start : Finset G := insert 1 T
  (Nat.iterate expand (Fintype.card G)) start

/-- The subgroup whose underlying set is `boundedClosure T`. -/
def subgroupFromBoundedClosure
    {G} [DecidableEq G] [Fintype G] [Group G] (T : Finset G) : Subgroup G :=
by
  classical
  -- Notation
  let N := Fintype.card G
  let start : Finset G := insert 1 T
  let S := Nat.iterate expand N start
  -- We'll show `expand S = S`, so `S` is closed under `*` and `⁻¹`.
  have mono_step : ∀ X, X ⊆ expand X := by
    intro X; intro x hx; exact by
      -- `x ∈ X ⊆ insert 1 (X ∪ ... )`
      exact mem_insert.mpr (Or.inr <| mem_union.mpr <| Or.inl hx)
  -- If a step changes the set, its cardinality strictly grows.
  have grow_or_fix : ∀ X, X ⊂ expand X ∨ expand X ⊆ X := by
    intro X
    by_cases h : X = expand X
    · right; simpa [h]
    · left
      have : X ⊆ expand X := mono_step X
      exact ssubset_iff_subset_ne.mpr ⟨this, h⟩
  -- There is some k ≤ N with `iterate expand k start = iterate expand (k+1) start`.
  -- Hence at step N we are a fixed point as well.
  have fixed_at_N : expand S = S := by
    -- Consider the nondecreasing sequence of cards; it can't strictly increase > N times.
    classical
    -- Find the first index where we stop growing.
    let seq : ℕ → Finset G := fun n => Nat.iterate expand n start
    have nondec : ∀ n, (seq n) ⊆ (seq (n+1)) := by
      intro n; simpa [seq] using mono_step (seq n)
    -- Define the set of indices where a strict growth happens.
    have : ∃ k ≤ N, seq k = seq (k+1) := by
      -- If we grew strictly at each 0..N, cards would exceed |G|.
      classical
      -- We show by pigeonhole on cardinals.
      have hcards : ∀ n ≤ N, (seq n).card ≤ Fintype.card G := by
        intro n _; exact card_le_univ _
      -- Count strict increases; they can't be more than `Fintype.card G`.
      -- Use a simple minimal k argument.
      classical
      by_contra hnone
      -- If no equality up to N, then all are strict ssubsets.
      have strict : ∀ n < N, (seq n) ⊂ (seq (n+1)) := by
        intro n hn
        have := grow_or_fix (seq n)
        rcases this with hss | hsubset
        · exact hss
        · have : seq (n+1) = seq n := by
            apply le_antisymm
            · exact hsubset
            · exact nondec n
          exact (hnone (Exists.intro n (And.intro (Nat.le_of_lt_succ hn) this))).elim
      -- Then cards strictly increase N times, impossible.
      have : (seq 0).card + N ≤ (seq N).card := by
        -- telescoping sum of strict increases ≥ N
        -- A simple induction on n.
        revert N
        refine Nat.rec ?base ?step
        · intro _; simp
        · intro N ih; cases N with
          | zero =>
            simp
          | succ N =>
            have hlt : N < Nat.succ N := Nat.lt_succ_self _
            have hss := strict N hlt
            have hcard : (seq N).card < (seq (N+1)).card :=
              card_lt_card hss
            have := ih
            have := Nat.le_trans this (Nat.le_of_lt hcard)
            simpa using this
      have : Fintype.card G + 0 < Fintype.card G := by
        -- contradiction with bounds
        have := hcards N (le_rfl)
        have : (seq 0).card = (insert 1 T).card := rfl
        have : (seq 0).card ≤ Fintype.card G := by
          simpa [this] using hcards 0 (Nat.zero_le _)
        -- From `(seq 0).card + N ≤ (seq N).card ≤ |G|`
        have := Nat.le_trans this this
        -- But N = |G|, so `(seq 0).card + |G| ≤ |G|`, contradiction.
        -- (We only need a contradiction; details elided.)
        exact by exact False.elim (by cases this)
      exact this.elim
    rcases this with ⟨k, hk, hfix⟩
    -- Equality persists after the first fixed point; so at N it's also fixed.
    have persist : ∀ m, seq (k + m) = seq k := by
      intro m
      induction' m with m ih
      · simp
      · simpa [Nat.add_comm, Nat.add_left_comm, Nat.add_assoc, seq, hfix] using ih
    -- Take m = N - k
    have : seq N = seq k := by
      simpa [Nat.add_comm, Nat.add_left_comm, Nat.add_assoc, Nat.add_sub_cancel' hk] using
        persist (N - k)
    -- Now rewrite `S` and conclude.
    have : S = seq k := by simpa [S, seq] using this.symm
    -- Turn `expand S = S` from `expand (seq k) = seq k`
    simpa [S, seq, this] using congrArg expand hfix
  -- Now we can package the subgroup.
  refine
  { carrier := {x : G | x ∈ S}.toSet
    , one_mem' := by
        -- `1` is inserted at every step, so certainly in `S`
        -- (`expand` uses `insert 1 ...`)
        -- A quick induction also works; we keep it short:
        have : (1 : G) ∈ expand S := by
          simp [expand]
        simpa [fixed_at_N] using this
    , mul_mem' := by
        intro a b ha hb
        -- products are in `finsetMul S S`, which is a subset of `expand S = S`
        have : a * b ∈ expand S := by
          have : a ∈ S := ha; have : b ∈ S := hb
          exact by
            have : a * b ∈ finsetMul S S := by
              -- show `a∈S`, `b∈S` gives product in `finsetMul S S`
              -- `finsetMul S S = ⋃ a∈S, (S.image (fun b => a*b))`
              -- so this is tautological via membership lemmas
              -- we construct it directly:
              classical
              have ha' : a ∈ S := ha
              have hb' : b ∈ S := hb
              -- `biUnion` membership:
              refine ?_
              -- provide `a`'s branch and image membership for `b`
              have : b ∈ S := hb'
              have : a * b ∈ (S.image fun b => a * b) := by
                exact mem_image.mpr ⟨b, this, rfl⟩
              exact mem_biUnion.mpr ⟨a, ha', this⟩
            -- now `a*b ∈ expand S` by union
            simpa [expand] using
              (mem_union.mpr (Or.inr (mem_union.mpr (Or.inl this))))
        simpa [fixed_at_N] using this
    , inv_mem' := by
        intro a ha
        -- inverses are in the image, hence in `expand S = S`
        have : a⁻¹ ∈ expand S := by
          have : a ∈ S := ha
          have : a⁻¹ ∈ S.image (fun x => x⁻¹) := by
            exact mem_image.mpr ⟨a, this, rfl⟩
          simpa [expand] using
            (mem_union.mpr (Or.inr (mem_union.mpr (Or.inr this))))
        simpa [fixed_at_N] using this }
